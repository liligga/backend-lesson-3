---
theme: seriph
background: https://cover.sli.dev
title: Урок 3 Python backend
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
---

# Добро пожаловать

---

### Принципы ООП

1. Наследование
2. Полиморфизм
3. Инкапсуляция
4. Абстракция

---

### Инкапсуляция в Python

**Инкапсуляция** — это механизм, который объединяет данные (атрибуты) и методы, работающие с этими данными, в единый объект и скрывает детали реализации от пользователя.

В Python инкапсуляция достигается с помощью соглашения об именовании. Атрибуты, которые не предназначены для прямого доступа извне, именуются с одним или двумя подчеркиваниями в начале.

- `_одно_подчеркивание`: атрибут считается **защищенным** (protected) и не должен изменяться вне класса.
- `__два_подчеркивания`: атрибут считается **приватным** (private), и его имя искажается, чтобы избежать случайного переопределения в дочерних классах.

---

### Инкапсуляция в Python

<CodeFontSize />

> Доступ к <span v-mark.highlight.green>защищенным и приватным</span> атрибутам **внутри** класса возможен.

> Доступ к <span v-mark.highlight.orange>защищенным</span> атрибутам извне возможен, но не рекомендуется.

> Доступ к <span v-mark.highlight.red>приватным</span> атрибутам **извне** класса возможен при помощи искажения имени. Но тоже не рекомендуется.


```python
class Car:
    def __init__(self):
        self.__speed = 60

car = Car()
car.__speed = 10 # будет ошибка
print(car.__speed) # будет ошибка
print(car._Car__speed)  # будет 60, так делают в крайнем случае
```

> Это называется искажением имени (name mangling).

---
layout: two-cols
---

### Инкапсуляция в Python

Для нормального доступа к приватным атрибутам используются методы (getter и setter) или `@property`

`@property` - это декоратор, который позволяет сделать метод доступным как атрибут

Инкапсуляция полезна для защиты данных от неправильного доступа и изменения, а также для проверок данных

::right::

```python
class Car:
    def __init__(self, max_speed):
        self.max_speed = max_speed
        self.__speed = 0  # Приватный атрибут

    def accelerate(self, acc):
        # setter
        if self.__speed + acc > self.max_speed:
            raise ValueError("Скорость не может быть больше максимальной")
        else:
            self.__speed += acc

    def get_speed(self):
        # getter
        return self.__speed

```

При попытке присвоить неправильное значение выше будет выброшено исключение(`ValueError`)

---

### Инкапсуляция в Python

<CodeFontSize />

Пример с `@property`:

```python
class Car:
    def __init__(self, max_speed):
        self.max_speed = max_speed
        self.__speed = 0  # Приватный атрибут

    @property
    def speed(self):
        # getter
        return self.__speed

    @speed.setter
    def speed(self, value):
        # setter
        if value > self.max_speed:
            raise ValueError("Скорость не может быть больше максимальной")
        else:
            self.__speed = value
```

При попытке присвоить неправильное значение выше будет выброшено исключение(`ValueError`)

---
layout: two-cols
---

### Абстракция в Python

**Абстракция** — это принцип, который позволяет скрывать сложные детали реализации, предоставляя пользователю только необходимый функционал. Она помогает сосредоточиться на том, ***что*** объект делает, а не на том, ***как*** он это делает.

В Python абстракция осуществляется с помощью абстрактных классов и методов из модуля `abc` (Abstract Base Classes).

<v-clicks>

- **Абстрактный класс** не может иметь экземпляров и служит шаблоном для других классов.

- **Абстрактный метод** объявляется, но не реализуется в абстрактном классе. Дочерние классы обязаны его реализовать.

</v-clicks>

::right::

<v-click>

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        # Реализация абстрактного метода
        print("Собака лает")

class Cat(Animal):
    def make_sound(self):
        # Реализация абстрактного метода
        print("Кошка мяукает")

dog = Dog()
cat = Cat()

dog.make_sound()
cat.make_sound()
```

</v-click>

---

### Абстракция в Python

> В примере выше Animal - это абстрактный класс, его нельзя ининциализировать.

<br>

> Dog и Cat - это дочерние классы, которые наследуются от Animal, они называются конкретными классами.

<br>

> Каждый конкретный класс обязан переопределить абстрактный метод make_sound. Это называется реализацией абстрактного метода. То есть конкретные классы реализуют методы абстрактного класса.

---
layout: two-cols
---

### Полиморфизм vs Абстракция

Часто эти понятия путают, так как они работают вместе.

**Абстракция (Проектирование):**
Фокус на том, **что** объект должен уметь делать. Мы создаем "контракт" (интерфейс).
*Пример:* "Любой `Notifier` обязан иметь метод `send`."

**Полиморфизм (Использование):**
Фокус на том, что мы можем использовать разные объекты **одинаковым** способом, не зная их точного типа.
*Пример:* "Функция `notify` просто вызывает `.send()`, не проверяя, это SMS или Telegram."

::right::

```python
from abc import ABC, abstractmethod

# 1. АБСТРАКЦИЯ
# Мы скрыли детали и задали контракт
class Notifier(ABC):
    @abstractmethod
    def send(self, message: str):
        pass

# Конкретные реализации
class SMS(Notifier):
    def send(self, message):
        print(f"Отправка SMS: {message}")

class Telegram(Notifier):
    def send(self, message):
        print(f"Отправка в Telegram: {message}")
```

---

### Полиморфизм в действии

Полиморфизм позволяет писать универсальный код, который работает с любыми реализациями нашей абстракции.

```python
# 2. ПОЛИМОРФИЗМ
# Функция не знает, какой именно Notifier ей передали.
# Она уверена, что у объекта есть метод send().
def send_alert(service: Notifier, text: str):
    service.send(text)

# Использование
sms_service = SMS()
tg_service = Telegram()

# Один и тот же код работает с разными типами
send_alert(sms_service, "Ваш код: 1234")
send_alert(tg_service, "Новое сообщение")
```

> Если завтра мы добавим `WhatsApp`, функцию `send_alert` **менять не придется**. Это и есть сила полиморфизма.

---

### 1. Что такое Абстракция? (Конструкция)

**Суть:** Мы определяем *стандарт* (интерфейс) и скрываем сложные детали.

*   **Фокус:** На вопросе **"ЧТО это делает?"**
*   **В коде:** Мы создали класс `Notifier` с пустым методом `send()`. Это просто обещание, что метод будет.

<br>

> **Аналогия: Розетка в стене**
> *   Вы видите только два отверстия. Это **Абстракция**.
> *   Вам не нужно знать схему проводки внутри стены, чтобы получить электричество.

---

### 2. Что такое Полиморфизм? (Использование)

**Суть:** Возможность использовать разные вещи *одним и тем же способом*.

*   **Фокус:** На вопросе **"КАК мы это используем?"**
*   **В коде:** Мы вызываем `.send()` и для SMS, и для Telegram. Код вызова один, а результат разный.

<br>

> **Аналогия: Вилки приборов**
> *   Вы можете включить в одну розетку Фен, Утюг или Зарядку. Это **Полиморфизм**.
> *   Интерфейс один (розетка), а **поведение** приборов разное (дует, греет, заряжает).

---
layout: two-cols
---

### Сравнение: Технический взгляд

| **Абстракция** | **Полиморфизм** |
| :--- | :--- |
| **Создает контракт** | **Исполняет контракт** |
| Отвечает на вопрос "ЧТО?" | Отвечает на вопрос "КАК?" |
| Скрывает сложность реализации | Позволяет подменять реализацию |

::right::

**Пример из урока:**

1.  **Абстракция:** Мы придумали класс `Notifier` и решили, что у всех будет метод `send`.

2.  **Полиморфизм:** Мы написали функцию `send_alert`, которая принимает *любой* `Notifier` и просто вызывает `send`, не заботясь о типе.

---

### Итог одной фразой

<div class="text-center text-2xl mt-20">

**Абстракция** — это карта местности (общий вид).

**Полиморфизм** — это возможность проехать по этой карте и на джипе, и на велосипеде.

</div>

---
layout: two-cols-header
---

### Общее

Все принципы ООП помогают сделать код более понятным и поддерживаемым.
Также есть более сложные принципы дизайна программного обеспечения - принципы SOLID.
Также есть паттерны программирования, связанные с ООП, которые помогают решать определенные задачи.

Полезные ссылки:

::left::

- [Принципы SOLID](https://solidbook.vercel.app/)
- [Про SOLID с примерами](https://habr.com/ru/companies/otus/articles/651753/)
- [Паттерны программирования](https://refactoring.guru/ru/design-patterns/catalog)
- [Паттерны с примерами](https://habr.com/ru/articles/930094/)

Штуки со знаком @ - это декораторы. Они используются для добавления дополнительной функциональности к функции или классу.

::right::

Более продвинутые статья про атрибуты в Python:
- [Статья #1](https://habr.com/ru/companies/otus/articles/896190/)
- [Статья #2](https://habr.com/ru/companies/otus/articles/889754/)
- [Статья #3](https://habr.com/ru/companies/otus/articles/801595/)
- [Статья #4](https://konstantinklepikov.github.io/myknowlegebase/notes/python-descriptors.html)

Про протоколы в Python:
- [Статья #1](https://habr.com/ru/companies/wunderfund/articles/751424/)

---

<Questions />